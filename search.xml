<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Promise之串行执行的实现</title>
      <link href="/2018/04/05/Promise%E7%9A%84%E4%B8%B2%E8%A1%8C%E6%89%A7%E8%A1%8C/"/>
      <url>/2018/04/05/Promise%E7%9A%84%E4%B8%B2%E8%A1%8C%E6%89%A7%E8%A1%8C/</url>
      <content type="html"><![CDATA[<blockquote><p><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">Promises/A+规范</a>了解一下？</p></blockquote><h1 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h1><p>通常如果说要实现 Promise 的串行执行，对于初学者（比如说我这种小菜鸟）来说，会不假思索的写出如下代码：</p><pre><code class="js">function executePromises(promises) {  var result = Promise.resolve();  promises.forEach(function (promise) {    result = result.then(promise);  });  return result;}</code></pre><p>但其实发现，和用 <code>Promise.all()</code> 实现的的效果是一样，都是并行执行。</p><p>那这是什么原因呢？</p><p><strong>依照 promises 规范，一旦一个 promise 被创建，它就被执行了。</strong>promises.forEach本意是顺序执行promise，也就是依次的，然而上面的代码，实际上promises并不会等待上一个promise结束就会开始执行。</p><h1 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h1><p>所以实现的关键点就在于，在执行 <code>executePromise</code> 之前不会创建 promise。</p><p>所以可以创建一个类似于下面的函数：</p><pre><code class="js">function createPromise() {  return new Promise((resolve)=&gt;{      doSomthing()      resolve()  });}</code></pre><p>然后将函数 <code>executePromises</code> 修改为：</p><pre><code class="js">function executePromises(createPromises) {  var result = Promise.resolve();  createPromises.forEach(function (createPromise) {    result = result.then(createPromise);  });  return result;}</code></pre><p>有了这两个函数，我们就可以使多个 Promise 串执行~</p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>为什么这样可以呢？</p><p>因为一个 createPromise 在被执行之前并不会创建 promise。它和一个 then 函数一样。</p><p>如果你查看上面的 <code>executePromises()</code> 函数，然后想象 <code>createPromise</code> 被包裹在 result.then(…) 之中,就像下面的样子：</p><pre><code class="js">result.resolve().then(createPromise).then(createPromise)...</code></pre><p>是不是就秒懂啦~这样就实现了 Promise 的串行执行~</p>]]></content>
      
      <categories>
          
          <category> Promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise串行执行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS中的层叠规则</title>
      <link href="/2018/04/05/CSS%E4%B8%AD%E7%9A%84%E5%B1%82%E5%8F%A0%E8%A7%84%E5%88%99/"/>
      <url>/2018/04/05/CSS%E4%B8%AD%E7%9A%84%E5%B1%82%E5%8F%A0%E8%A7%84%E5%88%99/</url>
      <content type="html"><![CDATA[<p>默认情况下，网页的内容是没有偏移角的垂直视觉呈现，当内容发生层叠时，就会产生一个有先后顺序的层叠。</p><a id="more"></a><h1 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h1><p>一般说到层叠首先就很容易想到 z-index 属性。</p><p>z-index 属性只和 position 不为 static 的元素在一起时才生效，可为负值也可为正值。</p><p>但是，在新出现的 CSS3 中，flex 盒子的子元素也可以设置 z-index 属性。</p><h1 id="层叠上下文和层叠水平"><a href="#层叠上下文和层叠水平" class="headerlink" title="层叠上下文和层叠水平"></a>层叠上下文和层叠水平</h1><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>层叠上下文(stacking context)是 HTML 中的一个三维的概念。可以理解为，某个元素含有层叠上下文那它就在 z 轴(当你看电脑屏幕时，视线和显示器之前的这条垂直线)上就会高于其他非层叠上下文元素。</p><p>层叠上下文和块级格式化上下文类似，每个层叠上下文中可能有其他的层叠上下文，而自身也有可能处于一个层叠上下文中。</p><h2 id="层叠水平"><a href="#层叠水平" class="headerlink" title="层叠水平"></a>层叠水平</h2><p>层叠水平(stacking level)决定了同一个层叠上下文中元素在 z 轴上的显示顺序。</p><p>包括层叠上下文元素和普通元素，网页上的每个元素都有层叠水平。只不过普通元素的层叠水平是无法和层叠上下文元素的层叠水平相较量的。</p><p>需要注意，不要把层叠水平和 CSS 的 z-index 属性混为一谈。z-index 对层叠水平的影响仅限于定位元素和 flex 盒子元素，而层叠水平适用于所有元素。</p><h1 id="元素的层叠顺序"><a href="#元素的层叠顺序" class="headerlink" title="元素的层叠顺序"></a>元素的层叠顺序</h1><p>层叠顺序(stacking order)表示发生层叠时垂直显示顺序。（类似于规则）</p><p>在 CSS3 之前的 CSS2.1 中，层叠规则可以类似这样表示：</p><p><img src="CSS中的层叠规则/z-index.png" alt="层叠顺序"></p><p>以上的层叠顺序规则仅适于当前层叠上下文。</p><p>注意：z-index: 0 和 z-index: auto，可以看成是一样的，但在层叠上下文中有着根本性的差异。</p><p>上图的层叠顺序从底到上可以理解为：装饰 =&gt; 布局 =&gt; 内容。</p><p>这样的话就很容易理解为什么要置这样一个顺序。在一个网页中最重要的是内容，其次是布局，最后是装饰。</p><h1 id="层叠准则"><a href="#层叠准则" class="headerlink" title="层叠准则"></a>层叠准则</h1><ol><li>谁的值大谁在上：在一个层叠上下文中，层叠水平大的元素会覆盖层叠水平小的元素。</li><li>后来元素在上：在同一个层叠上下文中，层叠水平一致、层叠顺序相同时，后面的元素会覆盖前面的元素。</li></ol><h1 id="深入理解层叠上下文"><a href="#深入理解层叠上下文" class="headerlink" title="深入理解层叠上下文"></a>深入理解层叠上下文</h1><h2 id="层叠上下文的特性"><a href="#层叠上下文的特性" class="headerlink" title="层叠上下文的特性"></a>层叠上下文的特性</h2><ol><li>层叠上下文的层叠水平要比普通元素高</li><li>层叠上下文可以阻断元素的混和模式</li><li>层叠上下文可以嵌套，内部的层叠上下文及其子元素受制于外部的层叠上下文</li><li>每个层叠上下文和兄弟元素独立。</li><li>每个层叠上下文是有体系的，当元素发生层叠时，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ol><h2 id="层叠上下文的创建"><a href="#层叠上下文的创建" class="headerlink" title="层叠上下文的创建"></a>层叠上下文的创建</h2><ol><li>默认的：页面根元素默认具有层叠上下文，即根层叠上下文。</li><li>z-index：z-index 值为数值的定位元素的传统“层叠上下文”。</li><li>CSS3 的一些属性</li></ol><h3 id="根层叠上下文"><a href="#根层叠上下文" class="headerlink" title="根层叠上下文"></a>根层叠上下文</h3><p>根层叠上下文是页面根元素，即<html>元素。所以，页面中所有的元素一定处于至少一个层叠上下文中。</html></p><h3 id="定位元素和传统层叠上下文"><a href="#定位元素和传统层叠上下文" class="headerlink" title="定位元素和传统层叠上下文"></a>定位元素和传统层叠上下文</h3><p>当定位元素的 z-index 的值不为 auto 时，会创建层叠上下文。</p><p>example：</p><p>position：fixed 属性使元素天然具有层叠上下文。</p><h3 id="CSS3-中的层叠上下文"><a href="#CSS3-中的层叠上下文" class="headerlink" title="CSS3 中的层叠上下文"></a>CSS3 中的层叠上下文</h3><ol><li>元素为 flex 布局元素同时 z-index 值不为 auto</li><li>元素的 opacity 值不是 1</li><li>元素的 transform 值不是 none</li><li>元素的 mix-blend-mode 值不是 normal</li><li>元素的 filter 不是 none</li><li>元素的 isolation 值是 isolation</li><li>元素的 will-change 属性为 2~6 中任意一个</li><li>元素的 -webkit-overflow-scrolling 为 touch</li></ol><h2 id="层叠上下文和层叠顺序"><a href="#层叠上下文和层叠顺序" class="headerlink" title="层叠上下文和层叠顺序"></a>层叠上下文和层叠顺序</h2><ol><li>如果层叠上下文元素不依赖 z-index 数值，即，z-index：auto 相当于 z-index：0</li><li>如果层叠上下文元素依赖 z-index 数值，则层叠顺序由 z-index 决定。</li></ol><p>元素一旦成为定位元素，就会自动具有 z-index：auto 属性。</p><p>不支持 z-index 的层叠上下文元素是天然 z-index：auto，和定位元素是一个层叠顺序，当它们发生层叠时，遵守“后来元素在上”的规则。</p><p>example：</p><h1 id="z-index负值深入理解"><a href="#z-index负值深入理解" class="headerlink" title="z-index负值深入理解"></a>z-index负值深入理解</h1><p>由之前的层叠顺序图可以看出来，z-index 负值元素的层级在层叠上下文上面、block 元素下面。</p><p>所以在一个层级上下文里不管 z-index 的负值再小，都不会突破当前层级上下文。</p><p>z-index 负值渲染的过程就是一个寻找第一个层叠上下文元素的过程，然后层叠顺序止步于这个层叠上下文元素。</p><p>应用：</p><h1 id="关于-z-index-注意事项"><a href="#关于-z-index-注意事项" class="headerlink" title="关于 z-index 注意事项"></a>关于 z-index 注意事项</h1><p>对于非浮层元素，避免设置z-index值，z-index值没有任何道理需要超过2。</p><ol><li>定位元素一旦设置了z-index值，就从普通定位元素变成了层叠上下文元素，相互间的层叠顺序就发生了根本的变化，很容易出现设置了巨大的z-index值也无法覆盖其他元素的问题。</li><li>避免z-index“一山比一山高”的样式混乱问题。</li></ol><p>DOM 顺序无法调整，不得不用 z-index 时，一定不要超过 2，如果超过 2，可以尝试用“relative最小化原则”来实现和利用元素原生的层叠顺序进行层及控制等。</p><p>但是当元素是 js 驱动的浮层组件时，</p><p>需要借助“层级计数器”来管理，原因如下：</p><p>（1）总会遇到意想不到的高层级元素；</p><p>（2）组件的覆盖规则具有动态性。</p><p>所谓“层级计数器”，实际上就是一段JavaScript脚本，会遍历所有<body>处于显示状态的子元素，并得到最大z-index值，和默认的z-index做比较。如果超出，则显示的组件的z-index自动加1，这样就不会出现有组件被其他组件覆盖的问题；如果不超出，就使用默认的z-index值。</body></p>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS层叠规则 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
